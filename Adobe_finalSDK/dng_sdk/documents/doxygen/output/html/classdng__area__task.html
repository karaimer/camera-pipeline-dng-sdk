<!--
    Copyright 2005-2009 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>DNG SDK 1.3: dng_area_task Class Reference</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td>
        <span style='font-size: 30px'><a href='index.html' style='color: black; border: none'>stlab.adobe.com</a></span>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="adobe_apollo.html">Adobe Air</a><br/>
        <a href="http://stlab.adobe.com/gil/">Adobe GIL</a><br/>
        <a href="http://labs.adobe.com">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://www.adobe.com/products/xmp/">Adobe XMP</a><br/>
        <a href="http://www.mozilla.org/projects/tamarin">Tamarin project<br/>(Mozilla Foundation)</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>dng_area_task Class Reference</h1><!-- doxytag: class="dng_area_task" -->Abstract class for rectangular processing operations with support for partitioning across multiple processing resources and observing memory constraints.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="dng__area__task_8h_source.html">dng_area_task.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for dng_area_task:</div>
<div class="dynsection">

<p><center><img src="classdng__area__task.png" usemap="#dng_area_task_map" border="0" alt=""></center>
<map name="dng_area_task_map">
<area href="classdng__filter__task.html" alt="dng_filter_task" shape="rect" coords="0,56,95,80">
</map>
</div>

<p>
<a href="classdng__area__task-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#5e4509ddd58d8d9c92be811c04e8e44e">MaxThreads</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#51b270428b59fbb9e02a2bc6b3e6de38">MinTaskArea</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual dng_point&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#9eeb5204467e48b87a765ea330dedc19">UnitCell</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual dng_point&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#814162ad8b52b4ac909363c55b34efc2">MaxTileSize</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual dng_rect&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#7771da16f53c442d2886ab3940e03988">RepeatingTile1</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual dng_rect&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#da4cafff85c55c798cb51291086aebd3">RepeatingTile2</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual dng_rect&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#5b9a1edd9e210716b139d61a90059426">RepeatingTile3</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#bace867a3dfaa4dee2643474cd4cc4e6">Start</a> (uint32 threadCount, const dng_point &amp;tileSize, <a class="el" href="classdng__memory__allocator.html">dng_memory_allocator</a> *allocator, <a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *sniffer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#ff21f0bc38f2833cf61e248ee884cec8">Process</a> (uint32 threadIndex, const dng_rect &amp;tile, <a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *sniffer)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#25bee7a806bea666b0ecca96089ab7a7">Finish</a> (uint32 threadCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">dng_point&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#6f2cc77c20dd4d65e8f4ae48a660262a">FindTileSize</a> (const dng_rect &amp;area) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#210c4e7459695da04cd4219a263896fb">ProcessOnThread</a> (uint32 threadIndex, const dng_rect &amp;area, const dng_point &amp;tileSize, <a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *sniffer)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#c25f7ccd3c4c9d0098ad39317d0ff1c5">Perform</a> (<a class="el" href="classdng__area__task.html">dng_area_task</a> &amp;task, const dng_rect &amp;area, <a class="el" href="classdng__memory__allocator.html">dng_memory_allocator</a> *allocator, <a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *sniffer)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c0b6b0a87f9fbe317a5c4c89606c558"></a><!-- doxytag: member="dng_area_task::fMaxThreads" ref="2c0b6b0a87f9fbe317a5c4c89606c558" args="" -->
uint32&nbsp;</td><td class="memItemRight" valign="bottom"><b>fMaxThreads</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a66f2ddc471b65d85824c1ca36f5740"></a><!-- doxytag: member="dng_area_task::fMinTaskArea" ref="1a66f2ddc471b65d85824c1ca36f5740" args="" -->
uint32&nbsp;</td><td class="memItemRight" valign="bottom"><b>fMinTaskArea</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5baabf8937c04992b838302a2c31f3ed"></a><!-- doxytag: member="dng_area_task::fUnitCell" ref="5baabf8937c04992b838302a2c31f3ed" args="" -->
dng_point&nbsp;</td><td class="memItemRight" valign="bottom"><b>fUnitCell</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f041d95d057b9c169171d84c4dc886a"></a><!-- doxytag: member="dng_area_task::fMaxTileSize" ref="0f041d95d057b9c169171d84c4dc886a" args="" -->
dng_point&nbsp;</td><td class="memItemRight" valign="bottom"><b>fMaxTileSize</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Abstract class for rectangular processing operations with support for partitioning across multiple processing resources and observing memory constraints. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6f2cc77c20dd4d65e8f4ae48a660262a"></a><!-- doxytag: member="dng_area_task::FindTileSize" ref="6f2cc77c20dd4d65e8f4ae48a660262a" args="(const dng_rect &amp;area) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dng_point dng_area_task::FindTileSize           </td>
          <td>(</td>
          <td class="paramtype">const dng_rect &amp;&nbsp;</td>
          <td class="paramname"> <em>area</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find tile size taking into account repeating tiles, unit cell, and maximum tile size. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>area</em>&nbsp;</td><td>Computation area for which to find tile size. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Tile</em>&nbsp;</td><td>size as height and width in point. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="dng__area__task_8h_source.html#l00090">MaxTileSize()</a>, <a class="el" href="dng__area__task_8cpp_source.html#l00048">RepeatingTile1()</a>, <a class="el" href="dng__area__task_8cpp_source.html#l00057">RepeatingTile2()</a>, <a class="el" href="dng__area__task_8cpp_source.html#l00066">RepeatingTile3()</a>, and <a class="el" href="dng__area__task_8h_source.html#l00079">UnitCell()</a>.</p>

<p>Referenced by <a class="el" href="dng__area__task_8cpp_source.html#l00225">Perform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="25bee7a806bea666b0ecca96089ab7a7"></a><!-- doxytag: member="dng_area_task::Finish" ref="25bee7a806bea666b0ecca96089ab7a7" args="(uint32 threadCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dng_area_task::Finish           </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>threadCount</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Task computation finalization and teardown method. Called after all resources have completed processing. Can be overridden to accumulate results and free resources allocated in Start.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadCount</em>&nbsp;</td><td>Number of threads used for processing. Same as value passed to Start. </td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="dng__area__task_8cpp_source.html#l00225">Perform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5e4509ddd58d8d9c92be811c04e8e44e"></a><!-- doxytag: member="dng_area_task::MaxThreads" ref="5e4509ddd58d8d9c92be811c04e8e44e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32 dng_area_task::MaxThreads           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the maximum number of threads (resources) that can be used for processing<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Number</em>&nbsp;</td><td>of threads, minimum of 1, that can be used for this task. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="814162ad8b52b4ac909363c55b34efc2"></a><!-- doxytag: member="dng_area_task::MaxTileSize" ref="814162ad8b52b4ac909363c55b34efc2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual dng_point dng_area_task::MaxTileSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for maximum size of a tile for processing. Often processing will need to allocate temporary buffers or use other resources that are either fixed or in limited supply. The maximum tile size forces further partitioning if the tile is bigger than this size.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Maximum</em>&nbsp;</td><td>tile size allowed for this area task. </td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="dng__area__task_8cpp_source.html#l00092">FindTileSize()</a>.</p>

</div>
</div><p>
<a class="anchor" name="51b270428b59fbb9e02a2bc6b3e6de38"></a><!-- doxytag: member="dng_area_task::MinTaskArea" ref="51b270428b59fbb9e02a2bc6b3e6de38" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32 dng_area_task::MinTaskArea           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for minimum area of a partitioned rectangle. Often it is not profitable to use more resources if it requires partitioning the input into chunks that are too small, as the overhead increases more than the speedup. This method can be ovreridden for a specific task to indicate the smallest area for partitioning. Default is 256x256 pixels.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Minimum</em>&nbsp;</td><td>area for a partitoned tile in order to give performant operation. (Partitions can be smaller due to small inputs and edge cases.) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c25f7ccd3c4c9d0098ad39317d0ff1c5"></a><!-- doxytag: member="dng_area_task::Perform" ref="c25f7ccd3c4c9d0098ad39317d0ff1c5" args="(dng_area_task &amp;task, const dng_rect &amp;area, dng_memory_allocator *allocator, dng_abort_sniffer *sniffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dng_area_task::Perform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdng__area__task.html">dng_area_task</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dng_rect &amp;&nbsp;</td>
          <td class="paramname"> <em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__memory__allocator.html">dng_memory_allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *&nbsp;</td>
          <td class="paramname"> <em>sniffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default resource partitioner that assumes a single resource to be used for processing. Implementations that are aware of multiple processing resources should override (replace) this method. This is usually done in <a class="el" href="classdng__host.html#793d5ebe4c51e075fb826386497ea5f1">dng_host::PerformAreaTask</a> . <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>The task to perform. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>area</em>&nbsp;</td><td>The area on which mage processing should be performed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>allocator</em>&nbsp;</td><td><a class="el" href="classdng__memory__allocator.html" title="Interface for dng_memory_block allocator.">dng_memory_allocator</a> to use for allocating temporary buffers, etc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sniffer</em>&nbsp;</td><td><a class="el" href="classdng__abort__sniffer.html" title="Class for signaling user cancellation and receiving progress updates.">dng_abort_sniffer</a> to use to check for user cancellation and progress updates. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="dng__area__task_8cpp_source.html#l00092">FindTileSize()</a>, <a class="el" href="dng__area__task_8cpp_source.html#l00085">Finish()</a>, <a class="el" href="dng__area__task_8cpp_source.html#l00156">ProcessOnThread()</a>, and <a class="el" href="dng__area__task_8cpp_source.html#l00075">Start()</a>.</p>

<p>Referenced by <a class="el" href="dng__host_8cpp_source.html#l00229">dng_host::PerformAreaTask()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ff21f0bc38f2833cf61e248ee884cec8"></a><!-- doxytag: member="dng_area_task::Process" ref="ff21f0bc38f2833cf61e248ee884cec8" args="(uint32 threadIndex, const dng_rect &amp;tile, dng_abort_sniffer *sniffer)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dng_area_task::Process           </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>threadIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dng_rect &amp;&nbsp;</td>
          <td class="paramname"> <em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *&nbsp;</td>
          <td class="paramname"> <em>sniffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Process one tile or fully partitioned area. This method is overridden by derived classes to implement the actual image processing. Note that the sniffer can be ignored if it is certain that a processing task will complete very quickly. This method should never be called directly but rather accessed via Process. There is no allocator parameter as all allocation should be done in Start.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadIndex</em>&nbsp;</td><td>0 to threadCount - 1 index indicating which thread this is. (Can be used to get a thread-specific buffer allocated in the Start method.) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tile</em>&nbsp;</td><td>Area to process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sniffer</em>&nbsp;</td><td><a class="el" href="classdng__abort__sniffer.html" title="Class for signaling user cancellation and receiving progress updates.">dng_abort_sniffer</a> to use to check for user cancellation and progress updates. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classdng__filter__task.html#c36eb01a3fbf8603046f62ede387b5a6">dng_filter_task</a>.</p>

<p>Referenced by <a class="el" href="dng__area__task_8cpp_source.html#l00156">ProcessOnThread()</a>.</p>

</div>
</div><p>
<a class="anchor" name="210c4e7459695da04cd4219a263896fb"></a><!-- doxytag: member="dng_area_task::ProcessOnThread" ref="210c4e7459695da04cd4219a263896fb" args="(uint32 threadIndex, const dng_rect &amp;area, const dng_point &amp;tileSize, dng_abort_sniffer *sniffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dng_area_task::ProcessOnThread           </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>threadIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dng_rect &amp;&nbsp;</td>
          <td class="paramname"> <em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dng_point &amp;&nbsp;</td>
          <td class="paramname"> <em>tileSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *&nbsp;</td>
          <td class="paramname"> <em>sniffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handle one resource's worth of partitioned tiles. Called after thread partitioning has already been done. Area may be further subdivided to handle maximum tile size, etc. It will be rare to override this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadIndex</em>&nbsp;</td><td>0 to threadCount - 1 index indicating which thread this is. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>area</em>&nbsp;</td><td>Tile area partitioned to this resource. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tileSize</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sniffer</em>&nbsp;</td><td><a class="el" href="classdng__abort__sniffer.html" title="Class for signaling user cancellation and receiving progress updates.">dng_abort_sniffer</a> to use to check for user cancellation and progress updates. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="classdng__area__task.html#ff21f0bc38f2833cf61e248ee884cec8">Process()</a>, <a class="el" href="dng__area__task_8cpp_source.html#l00048">RepeatingTile1()</a>, <a class="el" href="dng__area__task_8cpp_source.html#l00057">RepeatingTile2()</a>, <a class="el" href="dng__area__task_8cpp_source.html#l00066">RepeatingTile3()</a>, and <a class="el" href="dng__abort__sniffer_8cpp_source.html#l00202">dng_abort_sniffer::SniffForAbort()</a>.</p>

<p>Referenced by <a class="el" href="dng__area__task_8cpp_source.html#l00225">Perform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7771da16f53c442d2886ab3940e03988"></a><!-- doxytag: member="dng_area_task::RepeatingTile1" ref="7771da16f53c442d2886ab3940e03988" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dng_rect dng_area_task::RepeatingTile1           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for RepeatingTile1. RepeatingTile1, RepeatingTile2, and RepeatingTile3 are used to establish a set of 0 to 3 tile patterns for which the resulting partitions that the final Process method is called on will not cross tile boundaries in any of the tile patterns. This can be used for a processing routine that needs to read from two tiles and write to a third such that all the tiles are aligned and sized in a certain way. A RepeatingTile value is valid if it is non-empty. Higher numbered RepeatingTile patterns are only used if all lower ones are non-empty. A RepeatingTile pattern must be a multiple of UnitCell in size for all constraints of the partitionerr to be met. 
<p>Referenced by <a class="el" href="dng__area__task_8cpp_source.html#l00092">FindTileSize()</a>, and <a class="el" href="dng__area__task_8cpp_source.html#l00156">ProcessOnThread()</a>.</p>

</div>
</div><p>
<a class="anchor" name="da4cafff85c55c798cb51291086aebd3"></a><!-- doxytag: member="dng_area_task::RepeatingTile2" ref="da4cafff85c55c798cb51291086aebd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dng_rect dng_area_task::RepeatingTile2           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for RepeatingTile2. RepeatingTile1, RepeatingTile2, and RepeatingTile3 are used to establish a set of 0 to 3 tile patterns for which the resulting partitions that the final Process method is called on will not cross tile boundaries in any of the tile patterns. This can be used for a processing routine that needs to read from two tiles and write to a third such that all the tiles are aligned and sized in a certain way. A RepeatingTile value is valid if it is non-empty. Higher numbered RepeatingTile patterns are only used if all lower ones are non-empty. A RepeatingTile pattern must be a multiple of UnitCell in size for all constraints of the partitionerr to be met. 
<p>Referenced by <a class="el" href="dng__area__task_8cpp_source.html#l00092">FindTileSize()</a>, and <a class="el" href="dng__area__task_8cpp_source.html#l00156">ProcessOnThread()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5b9a1edd9e210716b139d61a90059426"></a><!-- doxytag: member="dng_area_task::RepeatingTile3" ref="5b9a1edd9e210716b139d61a90059426" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dng_rect dng_area_task::RepeatingTile3           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for RepeatingTile3. RepeatingTile1, RepeatingTile2, and RepeatingTile3 are used to establish a set of 0 to 3 tile patterns for which the resulting partitions that the final Process method is called on will not cross tile boundaries in any of the tile patterns. This can be used for a processing routine that needs to read from two tiles and write to a third such that all the tiles are aligned and sized in a certain way. A RepeatingTile value is valid if it is non-empty. Higher numbered RepeatingTile patterns are only used if all lower ones are non-empty. A RepeatingTile pattern must be a multiple of UnitCell in size for all constraints of the partitionerr to be met. 
<p>Referenced by <a class="el" href="dng__area__task_8cpp_source.html#l00092">FindTileSize()</a>, and <a class="el" href="dng__area__task_8cpp_source.html#l00156">ProcessOnThread()</a>.</p>

</div>
</div><p>
<a class="anchor" name="bace867a3dfaa4dee2643474cd4cc4e6"></a><!-- doxytag: member="dng_area_task::Start" ref="bace867a3dfaa4dee2643474cd4cc4e6" args="(uint32 threadCount, const dng_point &amp;tileSize, dng_memory_allocator *allocator, dng_abort_sniffer *sniffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dng_area_task::Start           </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>threadCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dng_point &amp;&nbsp;</td>
          <td class="paramname"> <em>tileSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__memory__allocator.html">dng_memory_allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *&nbsp;</td>
          <td class="paramname"> <em>sniffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Task startup method called before any processing is done on partitions. The Start method is called before any processing is done and can be overridden to allocate temporary buffers, etc.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadCount</em>&nbsp;</td><td>Total number of threads that will be used for processing. Less than or equal to MaxThreads. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tileSize</em>&nbsp;</td><td>Size of source tiles which will be processed. (Not all tiles will be this size due to edge conditions.) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>allocator</em>&nbsp;</td><td><a class="el" href="classdng__memory__allocator.html" title="Interface for dng_memory_block allocator.">dng_memory_allocator</a> to use for allocating temporary buffers, etc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sniffer</em>&nbsp;</td><td>Sniffer to test for user cancellation and to set up progress. </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classdng__filter__task.html#c0c789fefa4cb9597c6d8c3d3e106c10">dng_filter_task</a>.</p>

<p>Referenced by <a class="el" href="dng__area__task_8cpp_source.html#l00225">Perform()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9eeb5204467e48b87a765ea330dedc19"></a><!-- doxytag: member="dng_area_task::UnitCell" ref="9eeb5204467e48b87a765ea330dedc19" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual dng_point dng_area_task::UnitCell           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for dimensions of which partitioned tiles should be a multiple. Various methods of processing prefer certain alignments. The partitioning attempts to construct tiles such that the sizes are a multiple of the dimensions of this point.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>point giving preferred alignment in x and y </td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="dng__area__task_8cpp_source.html#l00092">FindTileSize()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="dng__area__task_8h_source.html">dng_area_task.h</a><li>dng_area_task.cpp</ul>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2009 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
